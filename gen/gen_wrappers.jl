include(joinpath(@__DIR__, "bind_generator.jl"))

# Read in the API definition macros from the definitions file
defs = read(joinpath(@__DIR__, "api_defs.jl"), String)
# Have Julia expand/run the @bind macro to generate expressions for all of the functions
exprs = Base.include_string(@__MODULE__, "@macroexpand1 begin\n" * defs * "\nend", "api_defs.jl")
# Insert the conditional version helper expression
prepend!(exprs.args, _libhdf5_build_ver_expr.args)
exprs = Base.remove_linenums!(exprs)

# Definitions which are not automatically generated, but should still be documented as
# part of the raw low-level API:
append!(bound_api["H5P"],
        ["h5p_get_class_name"])   # defined in src/api_helpers.jl
append!(bound_api["H5T"],
        ["h5t_get_member_name",   # defined in src/api_helpers.jl
         "h5t_get_tag"])          # defined in src/api_helpers.jl

# Now dump the text representation to disk
open(joinpath(@__DIR__, "..", "src", "api.jl"), "w") do fid
    println(fid, """
# This file is autogenerated by HDF5.jl's `gen/gen_wrappers.jl` and should not be editted.
#
# To add new bindings, define the binding in `gen/api_defs.jl`, re-run
# `gen/gen_wrappers.jl`, and commit the updated `src/api.jl`.
""")
    function triplequote(s::String, indent = "", prefix = "")
        ret = indent * prefix * "\"\"\"\n"
        for l in eachline(IOBuffer(s))
            ret *= isempty(l) ? "\n" : indent * l * "\n"
        end
        ret *= indent * "\"\"\"\n"
        return ret
    end
    for funcblock in exprs.args
        if isexpr(funcblock, :block, 2) && funcblock.args[1] isa String
            # Pretty print the doc string — default printing produces the string in just
            # one line with `\n` literals, so manually switch to triple quoted string.
            print(fid, triplequote(funcblock.args[1]))
            print(fid, funcblock.args[2], "\n\n")
        elseif isexpr(funcblock, :macrocall, 3) && funcblock.args[1] === Symbol("@static") &&
               isexpr(funcblock.args[3], :if, 2) &&
               isexpr(funcblock.args[3].args[2], :block, 2) &&
               funcblock.args[3].args[2].args[1] isa String
            # Work around the expression printer in this more complex case by printing
            # to a buffer and string-replacing a sentinel value
            docstr = funcblock.args[3].args[2].args[1]
            funcblock.args[3].args[2].args[1] = "SENTINEL_DOC"
            buf = sprint(print, funcblock)
            buf = replace(buf, r"^\s+\"SENTINEL_DOC\"\n"m => triplequote(docstr, " "^8, "@doc "))
            print(fid, buf, "\n\n")
        else
            # passthrough
            print(fid, funcblock, "\n\n")
        end
    end
end

# Also generate auto-docs that simply list all of the bound API functions
apidocs = ""
for (mod, desc, urltail) in (
    ("H5", "General Library Functions", "Library"),
    ("H5A", "Attribute Interface", "Attributes"),
    ("H5D", "Dataset Interface", "Datasets"),
    ("H5E", "Error Interface", "Error+Handling"),
    ("H5F", "File Interface", "Files"),
    ("H5G", "Group Interface", "Groups"),
    ("H5I", "Identifier Interface", "Identifiers"),
    ("H5L", "Link Interface", "Links"),
    ("H5O", "Object Interface", "Objects"),
    ("H5P", "Property Interface", "Property+Lists"),
    ("H5R", "Reference Interface", "References"),
    ("H5S", "Dataspace Interface", "Dataspaces"),
    ("H5T", "Datatype Interface", "Datatypes"),
    ("H5Z", "Filter Interface", "Filters"),
    ("H5DO", "Optimized Functions Interface", "Optimizations"),
    ("H5DS", "Dimension Scale Interface", "Dimension+Scales"),
    ("H5LT", "Lite Interface", "Lite"),
    ("H5TB", "Table Interface", "Tables"),
    )
    global apidocs
    funcs = join(sort!(bound_api[mod]), "\n")
    apidocs *= """
        ## [`$mod`](https://portal.hdfgroup.org/display/HDF5/$urltail) — $desc
        ```@docs
        $funcs
        ```

        """
end

open(joinpath(@__DIR__, "..", "docs", "src", "api_bindings.md"), "w") do fid
    write(fid,
"""
```@raw html
<!-- This file is auto-generated and should not be manually editted. To update, run the
gen/gen_wrappers.jl script -->
```
```@meta
CurrentModule = HDF5
```

# Low-level library bindings

At the lowest level, `HDF5.jl` operates by calling the public API of the HDF5 shared
library through a set of `ccall` wrapper functions.
This page documents the function names and nominal C argument types of the API which
have bindings in this package.
Note that in many cases, high-level data types are valid arguments through automatic
`ccall` conversions.
For instance, `HDF5Datatype` objects will be automatically converted to their `hid_t` ID
by Julia's `cconvert`+`unsafe_convert` `ccall` rules.

There are additional helper wrappers (often for out-argument functions) which are not
documented here.

$apidocs
"""
    )
end

nothing
